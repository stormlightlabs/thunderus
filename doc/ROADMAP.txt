*ROADMAP.txt*                                       Coding Agent (Thunderus) MVP

CODING AGENT MVP                                                 *agent-harness*
================================================================================

See |VISION.txt| for design philosophy, core principles, and milestone targets.

--------------------------------------------------------------------------------
CONTENTS                                                      *roadmap-contents*
--------------------------------------------------------------------------------

    I. Repo Scaffold + Config + Session Store ................. |agent-I|
   II. Provider Harness...Execution Infrastructure ............ |agent-II|
  III. TUI Harness ............................................ |agent-III|
   IV. TUI + Agent + CLI Integration .......................... |agent-IV|
    V. Core Text Processing Tools ............................. |agent-V|
   VI. Approvals + Sandboxing (Shell-First, Still Safe) ....... |agent-VI|
  VII. Diff-First Editing + Git Integration ................... |agent-VII|
 VIII. Markdown + JSONL Hybrid VCS ............................ |agent-VIII|
   IX. Mixed-Initiative Collaboration ......................... |agent-IX|
    X. Extensibility + Hardening .............................. |agent-X|
   XI. Session Recovery ....................................... |agent-XI|
  XII. Endnotes ............................................... |agent-XII|

--------------------------------------------------------------------------------
I. REPO SCAFFOLD + CONFIG + SESSION STORE                              *agent-I*
--------------------------------------------------------------------------------

See section |2026-01-12| for changes made.

--------------------------------------------------------------------------------
II. PROVIDER HARNESS + MINIMAL INTERACTIVE TUI                        *agent-II*
--------------------------------------------------------------------------------

See section |2026-01-13| for changes made.

--------------------------------------------------------------------------------
III. TUI HARNESS                                                     *agent-III*
--------------------------------------------------------------------------------

See section |2026-01-15| for changes made.

--------------------------------------------------------------------------------
IV. TUI + AGENT + CLI INTEGRATION                                     *agent-IV*
--------------------------------------------------------------------------------

See section |2026-01-15| for changes made.

--------------------------------------------------------------------------------
V. CORE TEXT PROCESSING TOOLS                                          *agent-V*
--------------------------------------------------------------------------------
Implement the fundamental text search and file manipulation tools that enable
the agent to explore codebases and make targeted edits. These tools form the
backbone of agentic code interaction.

Design target:
Claude Code's tool model - ripgrep-based search, safe edit primitives,
high-level abstractions over raw shell tools (grep, sed, awk).

Research shows agentic search using bash tools is more reliable than semantic
search. Successful agents treat shell tools as first-class citizens with careful
safety guardrails.

Search Tools
------------
- [x] Grep tool (ripgrep-based):
      - pattern-based search with regex support
      - file filtering with glob patterns (e.g., "*.rs", "*.{ts,tsx}")
      - output modes: files_with_matches (default), content, count
      - context lines support (-A, -B, -C flags)
      - case-insensitive search option
      - head_limit for result pagination
      - JSON output mode for structured results
      - fallback to grep if ripgrep unavailable
- [x] Glob tool (file pattern matching):
      - find files by name patterns (e.g., "**/*.rs", "src/**/test_*.rs")
      - sorted by modification time
      - respect .gitignore by default
      - fast file discovery for model context

Read Tools
----------
- [x] Read tool:
      - line-based file reading with numbers
      - offset + limit for large files (default: 2000 lines)
      - character truncation for long lines (2000 chars)
      - binary file detection (reject binary reads)
      - support common file types (code, text, markdown)
- [x] Integration with session state:
      - track read history for edit validation
      - required before Edit operations

Edit Tools
----------
- [x] Edit tool (safe find-replace):
      - exact string replacement in files
      - old_string uniqueness validation (fail if ambiguous)
      - replace_all option for bulk replacement
      - requires prior Read in session history
      - preserve exact indentation from Read output
      - atomic operation (all-or-nothing)
      - subject to approval mode gates
- [x] MultiEdit tool (atomic batch edits):
      - multiple find-replace operations in single file
      - all edits succeed or none applied
      - validation for non-overlapping edits
      - same safety requirements as Edit

Shell Tool Classification
-------------------------
- [x] Enhance command classifier for text tools:
      - recognize grep/rg/sed/awk patterns
      - classify risk level (grep=safe, sed -i=risky)
      - suggest safer alternatives (sed → Edit tool)
      - integrate with approval system

Safety & Approvals
------------------
- [x] Read-only tools bypass approval (Grep, Glob, Read)
- [x] Edit tools check approval mode:
      - read-only: reject all edits
      - auto: allow workspace edits, gate external paths
      - full-access: allow all (still logged)
- [x] Mandatory backups for risky operations
- [x] Pedagogical warnings on first unsafe tool use

Provider Integration
--------------------
- [x] Tool schema definitions for GLM-4.7 and Gemini
- [x] System prompt guidance:
      - "Use Grep for code search, not bash grep"
      - "Always Read before Edit"
      - "Prefer Edit over sed for safety"
- [x] Result formatting for model consumption
- [x] Error messages that teach (e.g., "Edit failed: old_string not unique")

Full-Access Mode
----------------
- [x] Direct sed exposure (gated, with backups)
- [x] Direct awk exposure (gated, read-only recommended)
- [x] Rationale: complex syntax, safety concerns, better abstracted by
      Edit tools

DoD:
- Grep, Glob, Read, Edit, and MultiEdit tools implemented and tested
- Tool dispatcher routes calls correctly
- Approval system enforces safety policies
- Session state tracks read/edit history
- Provider schemas include all tool definitions
- Models can reliably search codebases and make targeted edits without
  resorting to bash grep/sed/awk
- Full research documented in .sandbox/research_text_tools_2026_01_13.md

--------------------------------------------------------------------------------
VI. APPROVALS + SANDBOXING (SHELL-FIRST, STILL SAFE)                  *agent-VI*
--------------------------------------------------------------------------------
Make "anything in the shell" possible without turning the agent into malware.
Build on the basic approval system from Milestone II with policy enforcement
and pedagogical features.

Design target:
Codex's model: approval policies + sandbox modes + profiles[^2]

- [x] Approval mode enforcement:
      - wire `read-only`, `auto`, `full-access` modes into agent loop
      - `read-only`: consultative; no edits, no commands
      - `auto`: workspace edits + safe commands; gates risky ops (default)
      - `full-access`: still logged; explicit opt-in only[^3]
      - runtime mode switching via `/approvals` command
- [x] Sandbox policy enforcement:
      - define "workspace roots" in config
      - path allow/deny lists (sensitive dirs always denied: ~/.ssh, ~/.aws)
      - enforce tool access by path (block outside workspace)
      - default: no network commands unless approved[^2]
      - integration with tool dispatcher
- [x] Command classifier integration:
      - safe/risky/blocked categorization for shell commands
      - pedagogical suggestions (e.g., "Consider Edit tool instead of sed -i")
- [ ] Enhance action cards with teaching context (builds on Milestone II cards):
      - "What": operation in plain language
      - "Why": context for this action in task flow
      - "Scope": files/paths affected, blast radius
      - "Risk": classification with reasoning (why safe/risky)
      - "Result": exit code, key output, next step
- [ ] First-time contextual hints:
      - track taught concepts per session (e.g., "risky_command_explained")
      - show brief explainer on first encounter
        (e.g., "network commands need approval")
      - never nag - one-time hints only
      - persist teaching state in session metadata
- [ ] TUI integration:
      - mode indicator in status bar (Mode: AUTO | Net: OFF)
      - approval dialog with action card display

DoD:
- The agent can run `cargo test`, but will stop and ask before doing anything
  risky.

--------------------------------------------------------------------------------
VII. DIFF-FIRST EDITING + GIT INTEGRATION                            *agent-VII*
--------------------------------------------------------------------------------
Edits are *reviewable*, *reversible*, and *conflict-aware*.

Codex explicitly treats diffs and `git apply` failure modes as first-class
(e.g., `codex apply` exits non-zero if `git apply` fails). Mirror that rigor[^7]

- [ ] Patch queue:
      - states: `PROPOSED → APPROVED → APPLIED` or `REJECTED`
      - patch objects store base snapshot id + target files + hunks
- [ ] Unified diff generation contract for models:
      - patch-first is default; raw write is an escape hatch (heavily gated)
- [ ] Apply engine:
      - try `git apply` (or equivalent) and detect conflicts
      - on failure: enter conflict UI instead of "forcing it"
- [ ] Rollback/undo:
      - revert last applied patch (one keybind)
      - show `git diff` before/after
- [ ] Git metadata linkage:
      - attach session pointers via git notes
      - show "this commit came from session X" in TUI
- [ ] TUI enhancements (moved from Section III):
      - Diff Queue pane with hunk navigation
      - next/prev hunk keybinds
      - approve/reject individual hunks
- [ ] Hunk labeling with intent:
      - attach semantic labels to hunks
        (e.g., "Add error handling", "Remove deprecated fn")
      - display intent above each hunk in diff view
      - teach version control discipline through consistent labeling
- [ ] Pedagogical conflict messages:
      - on `git apply` failure, explain *why* conflict occurred
        (not just "conflict detected")
      - show conflicting regions with context
      - suggest resolution strategies (rebase, manual merge, discard)
      - first conflict triggers brief explainer on 3-way merge

DoD:
- "PR-stack feel" inside a TUI: accept hunks, undo safely, never lose work.

--------------------------------------------------------------------------------
VIII. MARKDOWN + JSONL HYBRID VCS                                   *agent-VIII*
--------------------------------------------------------------------------------
Your hybrid system is the canonical record of agent work, and it improves
collaboration and debugging.

- [ ] JSONL event model (append-only) in `events.jsonl`:
      - user msgs, model msgs, tool calls/results, approvals, patches,
      - shell outputs (by reference), git snapshots
- [ ] Materialized Markdown views:
      - `MEMORY.md` (always-loaded "project memory", Claude-style)
      - `PLAN.md` (current plan + checkpoints)
      - `DECISIONS.md` (ADR-lite)[^1]
- [ ] "CLAUDE.md compatibility":
      - if repo has `CLAUDE.md`, import it into context automatically because
        Claude Code uses it as auto-context[^1]
- [ ] View materializer:
      - deterministic regeneration from JSONL + explicit user edits logged as
        events
- [ ] Fast search:
      - ripgrep recipes surfaced in-app for events + views
- [ ] TUI enhancements (moved from Section III):
      - Context pane with view content
      - Files pane for file system browsing
      - `/plan`, `/review`, `/memory` slash commands
      - `@` file search in composer

DoD:
- You can reconstruct *exactly* what happened in a session and why.

--------------------------------------------------------------------------------
VIII-A. TIERED MEMORY CORE + STORE (REPO-NATIVE, AUDITABLE)        *agent-VIIIa*
--------------------------------------------------------------------------------
Goal:
Establish durable “external memory” that survives context limits and restarts,
while staying reviewable + git-friendly. Use a tiered design:
- Core memory: small, always-loaded
- Recall/Episodic: append-only session history + session recaps
- Semantic/Procedural: curated, reusable knowledge

Tasks:
- [ ] Define memory directory layout (repo-local, deterministic):
      - `.thunderus/memory/`
          - `core/`        (always loaded)
          - `semantic/`    (facts + ADR-lite)
          - `procedural/`  (playbooks)
          - `episodic/`    (session recaps)
          - `indexes/`     (manifests + search indexes)
- [ ] Core memory contract:
      - Small + stable (linted size caps; enforce headings; diffable)
      - Add:
          - `.thunderus/memory/core/CORE.md`
          - `.thunderus/memory/core/CORE.local.md` (gitignored)
      - Implement hierarchical load precedence (repo root → cwd):
          - merge + override rules documented in CORE.md
- [ ] Semantic memory contract:
      - `.thunderus/memory/semantic/DECISIONS/ADR-xxxx.md` (ADR-lite)
      - `.thunderus/memory/semantic/FACTS/*.md` (stable facts)
- [ ] Procedural memory contract:
      - `.thunderus/memory/procedural/PLAYBOOKS/*.md`
      - Each playbook: Preconditions, Steps, Verification, Rollback
- [ ] Memory writes are patch-driven:
      - memory updates are proposed as diffs in the patch queue
      - memory edits MUST be logged as VCS events (see VIII “events.jsonl”)

See |SCHEMAS.txt| section |schemas-memory-doc| for format specifications.

DoD:
- `.thunderus/memory/` exists with the required subtrees + lint rules.
- Memory docs are diffable, patch-driven, and always point back to provenance.

--------------------------------------------------------------------------------
VIII-B. LONG-TERM MEMORY STORE + RETRIEVAL                         *agent-VIIIb*
        (LEXICAL FIRST, VECTORS OPT-IN)
--------------------------------------------------------------------------------
Goal:
Make the agent reliably find the right memory at the right time without stuffing
everything into context. Default to lexical retrieval; optionally augment with
vector similarity later.

Tasks:
- [ ] Implement MemoryStore interface (backend: SQLite recommended):
      - put(namespace, key, content, metadata)
      - get(namespace, key)
      - search(query, filters) → ranked hits with snippets + citations
- [ ] Build lexical index over memory docs + selected session recaps:
      - FTS index fields: title, headings, tags, body, updated, path, kind
- [ ] Retrieval policy (wired into agent loop):
      - Before edits/tool execution: query memory store using task intent
      - Load top-k chunks into context (bounded)
      - Always include citations: file path + heading anchor + event ids
- [ ] Optional vector layer (config flag only):
      - embed semantic/procedural + selected episodic recaps
      - add similarity hits only when lexical confidence is low
- [ ] TUI:
      - “Memory hits” panel: results + reasons + quick open
- [ ] Slash commands:
      - `/memory search <q>`
      - `/memory pin <id>` (pin a doc/chunk into current context set)

See |SCHEMAS.txt| section |schemas-memory-store| for SQLite schema.

DoD:
- Memory search returns ranked results with provenance citations and paths.
- Index is rebuildable; no “mystery memory”.

--------------------------------------------------------------------------------
VIII-C. MEMORY GARDENER                                            *agent-VIIIc*
        (CONSOLIDATION, DRIFT CONTROL, AND HYGIENE)
--------------------------------------------------------------------------------
Goal:
Prevent memory rot. Convert raw session history into small, stable, reusable
memory artifacts (facts, ADRs, playbooks), without losing provenance.

Tasks:
- [ ] Consolidation pipeline (“episodic → semantic/procedural”):
      - Inputs: `events.jsonl`, patch events, snapshots
      - Outputs:
          - update FACTS (stable commands + gotchas)
          - create/update ADR-lite entries (durable decisions)
          - update PLAYBOOKS (repeatable workflows)
          - write session recap in `memory/episodic/YYYY-MM/<session>.md`
- [ ] Hygiene rules:
      - de-dup facts (single canonical location)
      - enforce size limits on core
      - require provenance links on all durable claims
- [ ] Drift checks:
      - if repo changed since `last_verified_commit`, mark docs “stale”
- [ ] “Memory PR” workflow:
      - gardener emits patch queue items (“Update memory: …”)
      - user approves/rejects like any other diff
- [ ] Tests:
      - golden tests for deterministic outputs from identical inputs

See |SCHEMAS.txt| section |schemas-gardener| for config format.

DoD:
- Memory stays small + correct: consolidation and drift marking are automatic.

--------------------------------------------------------------------------------
VIII-D. TRAJECTORY + INSPECTOR (DEBUGGABLE “WHY” FOR MEMORY)       *agent-VIIId*
--------------------------------------------------------------------------------
Goal:
Make it trivial to answer: “Why did the agent believe X?” by linking memory
assertions to the exact evidence in the session log and patch history.

Tasks:
- [ ] Standardize “trajectory view” extracted from `events.jsonl`
- [ ] Build inspector UI (TUI):
      - filter by tool, file, timestamp, risk class
      - jump: memory doc → provenance events → patch diff → affected file
- [ ] Require provenance backlinks:
      - every durable memory doc must cite event ids + patch ids

See |SCHEMAS.txt| section |schemas-events| for JSONL event format.

DoD:
- Inspector can trace any memory claim back to evidence events + diffs.

--------------------------------------------------------------------------------
IX. MIXED-INITIATIVE COLLABORATION                                    *agent-IX*
--------------------------------------------------------------------------------
When you work alongside the agent, it pauses, notices drift, and reconciles.

- [ ] Drift detection (mandatory gate at every step boundary):
      - compare repo snapshot IDs; if changed → stop and require reconcile
- [ ] "User right-of-way" state machine:
      - any keystroke/edit cancels generation or tool execution immediately
- [ ] Reconcile ritual (single predictable flow):
      1. summarize changed files/diffstat
      2. choose: update plan & continue / rebase pending patches / discard
      3. refresh context and revalidate plan before acting again
      - enhance with choice implications (teach trade-offs of each option)
      - first drift triggers brief explainer:
        "Agent paused - you edited files. Let's reconcile"
- [ ] File ownership rule:
      - files you touched become "user-owned"; agent needs explicit approval to
        modify them until reconcile completes
- [ ] Advisor mode toggle:
      - consultative suggestions only (maps to read-only/approval modes)[^3]
- [ ] TUI enhancements (moved from Section III):
      - History editing: "edit previous message / fork from point"
      - Esc-based rewind behavior

DoD:
- The agent never proceeds on stale assumptions after you fix something manually

--------------------------------------------------------------------------------
X. EXTENSIBILITY + HARDENING                                           *agent-X*
--------------------------------------------------------------------------------
Match the "pro tool" feel: pluggable integrations, automation entrypoints,
and regression tests for harness behaviors.

- [ ] MCP client:
      - load MCP servers from config, import tool schemas, route calls
      - respect approval/sandbox across MCP tools[^8]
- [ ] Web search tool:
      - either provider-native (Gemini tools) or shell-gated `web_search`
        equivalent
            - Mojeek API
            - Brave API
            - Tavily API
      - treat results as tool outputs and log them[^9]
- [ ] Non-interactive mode (`thunderus exec "…"`) like Codex's `exec`:
      - emits JSON (machine output) + writes JSONL session log[^3]
- [ ] "review agent" (second pass) like Codex `/review` flow[^3]
- [ ] Harness regression tests (golden scenarios):
      - interrupt mid-tool, drift+reconcile, patch conflict UI, approval gating
- [ ] TUI enhancements (moved from Section III):
      - Permissions pane in sidebar
      - toggle verbose action trace keybind
- [ ] Session-based teaching state:
      - persist "taught concepts" in session metadata
      - track which pedagogical hints have been shown
        (e.g., `taught: [patch_conflict, risky_command]`)
      - prevent repetitive hints across session lifecycle
      - expose teaching history in session events for debugging

DoD:
- A daily-driver harness: interactive + scriptable + extensible.


--------------------------------------------------------------------------------
XI. Parking Lot                                                       *agent-XI*
--------------------------------------------------------------------------------

Session Recovery:
- Interactive session selection UI (list multiple sessions with metadata)
- Session search and filtering (by date, keyword, etc.)
- Session branching (fork from a previous session)
- Session export/import (share sessions between machines)
- Session metadata (title, tags, description)

--------------------------------------------------------------------------------
XII. REFERENCES                                                      *agent-XII*
--------------------------------------------------------------------------------

See |REFS.txt| for external resources, design inspirations, and footnotes.
