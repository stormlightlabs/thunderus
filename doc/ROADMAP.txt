*ROADMAP.txt*                                       Coding Agent (Thunderus) MVP

CODING AGENT MVP                                                 *agent-harness*
================================================================================

Replicate the *harness* quality of Claude Code + Codex CLI:
tight TUI loop, diff-first edits, explicit approvals/sandboxing, ergonomic
"composer" UX, and a workflow that is safe, scriptable, and hard to derail[^1]

- Rust, TUI-first (UI inspiration: OpenCode + Crush; keybinds: Claude/Codex)
- Shell tools are first-class ("anything in the shell" is usable, but gated)
- Dual providers: GLM-4.7 + Gemini
- First-class Markdown + JSONL hybrid VCS (audit + projections)
- Mixed-initiative: no "short-circuiting" when you work alongside the agent

--------------------------------------------------------------------------------
CONTENTS                                                      *roadmap-contents*
--------------------------------------------------------------------------------

    I. Repo Scaffold + Config + Session Store .................. |agent-I|
   II. Provider Harness...Execution Infrastructure ............. |agent-II|
  III. TUI Harness (Composer UX, Keybinds, Panels) ............. |agent-III|
   IV. Approvals + Sandboxing (Shell-First, Still Safe) ........ |agent-IV|
    V. Diff-First Editing + Git Integration .................... |agent-V|
   VI. Markdown + JSONL Hybrid VCS ............................. |agent-VI|
  VII. Mixed-Initiative Collaboration .......................... |agent-VII|
 VIII. Extensibility + Hardening ............................... |agent-VIII|
   IX. Endnotes ................................................ |roadmap-notes|

--------------------------------------------------------------------------------
I. REPO SCAFFOLD + CONFIG + SESSION STORE                              *agent-I*
--------------------------------------------------------------------------------

Goal:
Lay down the filesystem + config "spine" so everything else plugs in cleanly.

Tasks:
- [x] Create Cargo workspace:
      - `crates/cli`          (bin) [thunderus]
      - `crates/ui`           (lib) [thunderus_ui]
      - `crates/core`         (lib) [thunderus_core]
      - `crates/tools`        (lib) [thunderus_tools]
      - `crates/providers`    (lib) [thunderus_providers]
      - `crates/store`        (lib) [thunderus_store]
- [x] Define `.agent/` layout (repo-local, versionable):
      - `.agent/sessions/<timestamp>/events.jsonl`
      - `.agent/sessions/<timestamp>/patches/*.patch`
      - `.agent/views/{MEMORY.md,PLAN.md,DECISIONS.md}`
- [x] Implement `config.toml` with *profiles* (Codex-like ergonomics):
      - Use serde, toml, and `derive` to define the config struct with
        a root level example (`config.example.toml`)
      - profile name, working root, extra writable roots, approval mode,
      - sandbox mode, provider/model selection[^2]
- [x] Implement `SessionId` + monotonic `seq` event numbering in JSONL store.
- [x] Implement CLI entry point with argument parsing:
      - Colored output using owo-colors
      - Load config.toml from current directory or create from example
      - Support `thunderus start`, `thunderus exec <cmd>`, and
        `thunderus status` subcommands
      - Add thunderus_core dependency to cli/Cargo.toml
- [x] Implement session initialization:
      - Create `.agent/` directory layout on first run
      - Generate SessionId and create session directory
- [x] Implement event logging on session start:
      - Append session-start event to events.jsonl immediately
- [x] Implement placeholder interactive loop:
      - Placeholder for future TUI/interactive functionality

Definition of Done (DoD):
- Running `thunderus` creates a session folder and appends events immediately.

--------------------------------------------------------------------------------
II. PROVIDER HARNESS + TOOL-CALLING & EXECUTION INFRASTRUCTURE        *agent-II*
--------------------------------------------------------------------------------
A provider-agnostic agent loop with streaming, cancellation, tool calls,
and execution infrastructure needed before TUI can be functional.

- [x] Define provider-neutral types:
      - `ChatRequest/ChatResponse`, `ToolSpec`, `ToolCall`, `ToolResult`,
      - `StreamEvent`, `CancelToken`
- [x] Define tool execution framework:
      - Tool trait/interface for tool implementations
      - Tool registry and dispatcher
      - Basic tool implementations (test tools: `echo`, `noop`)
- [x] Implement command classification:
      - "safe": tests, formatters, linters
      - "risky": package install, shell piping, file deletion, network tooling
      - classification logic in tool execution layer
- [x] Expose classification reasoning in tool results:
      - include "why safe" or "why risky" explanation in tool metadata
      - foundation for teaching users the safety model through consistency
- [ ] Define basic approval protocol/trait:
      - Approval request/response types
      - Approval decision tracking
      - Integration with agent loop to pause for user approval
- [ ] Implement GLM-4.7 adapter:
      - `tools` + `tool_choice`-style function calling[^5]
      - streaming support with `StreamEvent` channel
- [ ] Implement Gemini adapter:
      - function calling + tool schema wiring[^4]
      - streaming support with `StreamEvent` channel
- [ ] Implement streaming output plumbing:
      - token stream from provider to TUI via channel
      - reliable cancel (user interrupt always wins via `CancelToken`)
- [ ] Core agent loop:
      - build context → model → tool calls → check approvals → execute tools
        → append results → repeat
      - integration with streaming and cancellation

DoD:
- "Hello tool": model calls `echo` tool and the agent executes it on both
  providers, requiring approval for non-safe operations.

--------------------------------------------------------------------------------
III. TUI HARNESS (COMPOSER UX, KEYBINDS, PANELS)                     *agent-III*
--------------------------------------------------------------------------------
A Codex/Claude-class interactive experience: composer-first, fast navigation,
and a transcript that shows actions. Use Ratatui for the Rust TUI foundation[^6]

- [ ] Layout:
      - Header: cwd, git branch, profile, provider/model, approval/sandbox state
      - Main: transcript (messages + tool/action cards)
      - Right pane (tabs): Command Output (basic)
      - Left sidebar: Token Usage (teach LLM cost model),
        Session Events (basic list), modified files (scope awareness),
        git diff queue, approval gates triggered (safety model),
        LSPs & MCPs (placeholders)
      - Footer: composer + hints
- [ ] Composer features modeled after Codex CLI:
      - `!cmd` runs a local command and inserts output as a user-provided result
        (subject to approvals/sandbox)[^3]
      - `Ctrl+G` opens $VISUAL/$EDITOR for long prompts[^3]
      - Basic message history (up/down arrow navigation)
- [ ] Base set of slash commands:
      - `/model`, `/approvals`, `/status`[^3]
- [ ] Keybind pack (Claude/Codex-inspired essentials):
      - cancel generation/tool
      - approve/reject tool calls
      - open panes (Output)
- [ ] Add shell completions generation (bash/zsh/fish) for the CLI entrypoint
      (Codex CLI explicitly supports this; it's a baseline harness feature)[^3]
- [ ] Progressive disclosure for action cards:
      - Level 1 (default): intent + outcome (brief, scannable)
      - Level 2 (expand): detailed context, scope, execution metadata
      - Level 3 (verbose mode): full logs, reasoning chain, trace
      - implement expand/collapse UI components with keybinds
- [ ] Verbosity controls:
      - toggle between default/verbose/quiet output modes
      - persist preference per session
      - surface in header with current mode indicator

DoD:
- A TUI that displays agent messages, shows tool call approval prompts,
  and streams model responses as tokens arrive.

--------------------------------------------------------------------------------
IV. APPROVALS + SANDBOXING (SHELL-FIRST, STILL SAFE)                   *agent-D*
--------------------------------------------------------------------------------
Make "anything in the shell" possible without turning the agent into malware.

Design target:
Codex's model: approval policies + sandbox modes + profiles[^2]

- [ ] Approval modes (at least these three):
      - `read-only` (consultative; no edits, no commands)
      - `auto` (workspace edits + safe commands; gates risky ops)
      - `full-access` (still logged; you opt in explicitly)[^3]
- [ ] Sandbox modes (MVP = policy sandbox; OS sandbox later):
      - define "workspace roots" and enforce tool access by path
      - default: no network commands unless approved[^2]
- [ ] "Action cards" in transcript:
      - every tool call shows: intent, inputs, scope (paths), risk flags
      - approvals are per action (and logged)
- [ ] Enhance action cards with teaching context:
      - "What": operation in plain language
      - "Why": context for this action in task flow
      - "Scope": files/paths affected, blast radius
      - "Risk": classification with reasoning (why safe/risky)
      - "Result": exit code, key output, next step
- [ ] First-time contextual hints:
      - track taught concepts per session (e.g., "risky_command_explained")
      - show brief explainer on first encounter
        (e.g., "network commands need approval")
      - never nag - one-time hints only

DoD:
- The agent can run `cargo test`, but will stop and ask before doing anything
  risky.

--------------------------------------------------------------------------------
V. DIFF-FIRST EDITING + GIT INTEGRATION                                *agent-E|
--------------------------------------------------------------------------------
Edits are *reviewable*, *reversible*, and *conflict-aware*.

Codex explicitly treats diffs and `git apply` failure modes as first-class
(e.g., `codex apply` exits non-zero if `git apply` fails). Mirror that rigor[^7]

- [ ] Patch queue:
      - states: `PROPOSED → APPROVED → APPLIED` or `REJECTED`
      - patch objects store base snapshot id + target files + hunks
- [ ] Unified diff generation contract for models:
      - patch-first is default; raw write is an escape hatch (heavily gated)
- [ ] Apply engine:
      - try `git apply` (or equivalent) and detect conflicts
      - on failure: enter conflict UI instead of "forcing it"
- [ ] Rollback/undo:
      - revert last applied patch (one keybind)
      - show `git diff` before/after
- [ ] Git metadata linkage:
      - attach session pointers via git notes
      - show "this commit came from session X" in TUI
- [ ] TUI enhancements (moved from Section III):
      - Diff Queue pane with hunk navigation
      - next/prev hunk keybinds
      - approve/reject individual hunks
- [ ] Hunk labeling with intent:
      - attach semantic labels to hunks
        (e.g., "Add error handling", "Remove deprecated fn")
      - display intent above each hunk in diff view
      - teach version control discipline through consistent labeling
- [ ] Pedagogical conflict messages:
      - on `git apply` failure, explain *why* conflict occurred
        (not just "conflict detected")
      - show conflicting regions with context
      - suggest resolution strategies (rebase, manual merge, discard)
      - first conflict triggers brief explainer on 3-way merge

DoD:
- "PR-stack feel" inside a TUI: accept hunks, undo safely, never lose work.

--------------------------------------------------------------------------------
VI. MARKDOWN + JSONL HYBRID VCS                                       *agent-VI|
--------------------------------------------------------------------------------
Your hybrid system is the canonical record of agent work, and it improves
collaboration and debugging.

- [ ] JSONL event model (append-only) in `events.jsonl`:
      - user msgs, model msgs, tool calls/results, approvals, patches,
      - shell outputs (by reference), git snapshots
- [ ] Materialized Markdown views:
      - `MEMORY.md` (always-loaded "project memory", Claude-style)
      - `PLAN.md` (current plan + checkpoints)
      - `DECISIONS.md` (ADR-lite)[^1]
- [ ] "CLAUDE.md compatibility":
      - if repo has `CLAUDE.md`, import it into context automatically because
        Claude Code uses it as auto-context[^1]
- [ ] View materializer:
      - deterministic regeneration from JSONL + explicit user edits logged as
        events
- [ ] Fast search:
      - ripgrep recipes surfaced in-app for events + views
- [ ] TUI enhancements (moved from Section III):
      - Context pane with view content
      - Files pane for file system browsing
      - `/plan`, `/review`, `/memory` slash commands
      - `@` file search in composer

DoD:
- You can reconstruct *exactly* what happened in a session and why.

--------------------------------------------------------------------------------
VII. MIXED-INITIATIVE COLLABORATION                                  *agent-VII|
--------------------------------------------------------------------------------
When you work alongside the agent, it pauses, notices drift, and reconciles.

- [ ] Drift detection (mandatory gate at every step boundary):
      - compare repo snapshot IDs; if changed → stop and require reconcile
- [ ] "User right-of-way" state machine:
      - any keystroke/edit cancels generation or tool execution immediately
- [ ] Reconcile ritual (single predictable flow):
      1. summarize changed files/diffstat
      2. choose: update plan & continue / rebase pending patches / discard
      3. refresh context and revalidate plan before acting again
      - enhance with choice implications (teach trade-offs of each option)
      - first drift triggers brief explainer:
        "Agent paused - you edited files. Let's reconcile"
- [ ] File ownership rule:
      - files you touched become "user-owned"; agent needs explicit approval to
        modify them until reconcile completes
- [ ] Advisor mode toggle:
      - consultative suggestions only (maps to read-only/approval modes)[^3]
- [ ] TUI enhancements (moved from Section III):
      - History editing: "edit previous message / fork from point"
      - Esc-based rewind behavior

DoD:
- The agent never proceeds on stale assumptions after you fix something manually

--------------------------------------------------------------------------------
VIII. EXTENSIBILITY + HARDENING                                     *agent-VIII|
--------------------------------------------------------------------------------
Match the "pro tool" feel: pluggable integrations, automation entrypoints,
and regression tests for harness behaviors.

- [ ] MCP client:
      - load MCP servers from config, import tool schemas, route calls
      - respect approval/sandbox across MCP tools[^8]
- [ ] Web search tool:
      - either provider-native (Gemini tools) or shell-gated `web_search`
        equivalent
            - Mojeek API
            - Brave API
            - Tavily API
      - treat results as tool outputs and log them[^9]
- [ ] Non-interactive mode (`thunderus exec "…"`) like Codex's `exec`:
      - emits JSON (machine output) + writes JSONL session log[^3]
- [ ] "review agent" (second pass) like Codex `/review` flow[^3]
- [ ] Harness regression tests (golden scenarios):
      - interrupt mid-tool, drift+reconcile, patch conflict UI, approval gating
- [ ] TUI enhancements (moved from Section III):
      - Permissions pane in sidebar
      - toggle verbose action trace keybind
- [ ] Session-based teaching state:
      - persist "taught concepts" in session metadata
      - track which pedagogical hints have been shown
        (e.g., `taught: [patch_conflict, risky_command]`)
      - prevent repetitive hints across session lifecycle
      - expose teaching history in session events for debugging

DoD:
- A daily-driver harness: interactive + scriptable + extensible.

--------------------------------------------------------------------------------
IX. NOTES                                                        *roadmap-notes*
--------------------------------------------------------------------------------

- Codex CLI: approval modes, sandbox/approvals posture, composer affordances
  (`@` file search, `!` local commands), slash commands, prompt editor[^3]
- Claude Code: repo-local memory file (`CLAUDE.md`) auto-loaded as context[^1]
- MCP: standardized tool/plugin surface to avoid hardcoding integrations[^10]
- Progressive Disclosure: UX pattern for teaching through staged information reveal,
  reducing cognitive load while supporting power users[^11][^12]. Research shows 90%
  of organizations consider AI transparency essential, and explainability is key to
  building trust in agentic systems[^13][^14]

[^1]: https://www.anthropic.com/engineering/claude-code-best-practices
[^2]: https://developers.openai.com/codex/security/
[^3]: https://developers.openai.com/codex/cli/features/
[^4]: https://ai.google.dev/gemini-api/docs/function-calling
[^5]: https://docs.z.ai/guides/llm/glm-4.7
[^6]: https://ratatui.rs/
[^7]: https://developers.openai.com/codex/cli/reference/
[^8]: https://modelcontextprotocol.io/
[^9]: https://ai.google.dev/gemini-api/docs/tools
[^10]: https://modelcontextprotocol.io/specification/2025-11-25
[^11]: https://www.nngroup.com/articles/progressive-disclosure/
[^12]: https://blog.logrocket.com/ux-design/progressive-disclosure-ux-types-use-cases/
[^13]: https://arxiv.org/html/2502.13767v3
       (Agentic AI Software Engineers: Programming with Trust)
[^14]: https://witness.ai/blog/ai-transparency/
