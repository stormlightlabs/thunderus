*ROADMAP.txt*                                       Coding Agent (Thunderus) MVP

CODING AGENT MVP                                                 *agent-harness*
================================================================================

Replicate the *harness* quality of Claude Code + Codex CLI:
tight TUI loop, diff-first edits, explicit approvals/sandboxing, ergonomic
"composer" UX, and a workflow that is safe, scriptable, and hard to derail[^1]

- Rust, TUI-first (UI inspiration: OpenCode + Crush; keybinds: Claude/Codex)
- Shell tools are first-class ("anything in the shell" is usable, but gated)
- Dual providers: GLM-4.7 + Gemini
- First-class Markdown + JSONL hybrid VCS (audit + projections)
- Mixed-initiative: no "short-circuiting" when you work alongside the agent

--------------------------------------------------------------------------------
CONTENTS                                                      *roadmap-contents*
--------------------------------------------------------------------------------

    I. Repo Scaffold + Config + Session Store .................. |agent-I|
   II. Provider Harness...Execution Infrastructure ............. |agent-II|
  III. TUI Harness ............................................. |agent-III|
   IV. Approvals + Sandboxing (Shell-First, Still Safe) ........ |agent-IV|
    V. Diff-First Editing + Git Integration .................... |agent-V|
   VI. Markdown + JSONL Hybrid VCS ............................. |agent-VI|
  VII. Mixed-Initiative Collaboration .......................... |agent-VII|
 VIII. Extensibility + Hardening ............................... |agent-VIII|
   IX. Endnotes ................................................ |roadmap-notes|

--------------------------------------------------------------------------------
I. REPO SCAFFOLD + CONFIG + SESSION STORE                              *agent-I*
--------------------------------------------------------------------------------

Goal:
Lay down the filesystem + config "spine" so everything else plugs in cleanly.

Tasks:
- [x] Create Cargo workspace:
      - `crates/cli`          (bin) [thunderus]
      - `crates/ui`           (lib) [thunderus_ui]
      - `crates/core`         (lib) [thunderus_core]
      - `crates/tools`        (lib) [thunderus_tools]
      - `crates/providers`    (lib) [thunderus_providers]
      - `crates/store`        (lib) [thunderus_store]
- [x] Define `.agent/` layout (repo-local, versionable):
      - `.agent/sessions/<timestamp>/events.jsonl`
      - `.agent/sessions/<timestamp>/patches/*.patch`
      - `.agent/views/{MEMORY.md,PLAN.md,DECISIONS.md}`
- [x] Implement `config.toml` with *profiles* (Codex-like ergonomics):
      - Use serde, toml, and `derive` to define the config struct with
        a root level example (`config.example.toml`)
      - profile name, working root, extra writable roots, approval mode,
      - sandbox mode, provider/model selection[^2]
- [x] Implement `SessionId` + monotonic `seq` event numbering in JSONL store.
- [x] Implement CLI entry point with argument parsing:
      - Colored output using owo-colors
      - Load config.toml from current directory or create from example
      - Support `thunderus start`, `thunderus exec <cmd>`, and
        `thunderus status` subcommands
      - Add thunderus_core dependency to cli/Cargo.toml
- [x] Implement session initialization:
      - Create `.agent/` directory layout on first run
      - Generate SessionId and create session directory
- [x] Implement event logging on session start:
      - Append session-start event to events.jsonl immediately
- [x] Implement placeholder interactive loop:
      - Placeholder for future TUI/interactive functionality

Definition of Done (DoD):
- Running `thunderus` creates a session folder and appends events immediately.

--------------------------------------------------------------------------------
II. PROVIDER HARNESS + MINIMAL INTERACTIVE TUI                        *agent-II*
--------------------------------------------------------------------------------
A provider-agnostic agent loop with streaming, tool calls, and a minimal
but functional TUI. This creates an end-to-end testable system.

- [x] Define provider-neutral types:
      - `ChatRequest/ChatResponse`, `ToolSpec`, `ToolCall`, `ToolResult`,
      - `StreamEvent`, `CancelToken`
- [x] Define tool execution framework:
      - Tool trait/interface for tool implementations
      - Tool registry and dispatcher
      - Basic tool implementations (test tools: `echo`, `noop`)
- [x] Implement command classification:
      - "safe": tests, formatters, linters
      - "risky": package install, shell piping, file deletion, network tooling
      - classification logic in tool execution layer
- [x] Expose classification reasoning in tool results:
      - include "why safe" or "why risky" explanation in tool metadata
      - foundation for teaching users the safety model through consistency
- [x] Define approval protocol/trait:
      - Approval request/response types (ActionType, ApprovalContext)
      - Approval decision tracking (ApprovalGate, ApprovalRecord)
      - ApprovalProtocol trait for pluggable backends
- [x] Implement GLM-4.7 adapter:
      - `tools` + `tool_choice`-style function calling[^5]
      - streaming support with `StreamEvent` channel
- [x] Implement Gemini adapter:
      - function calling + tool schema wiring[^4]
      - streaming support with `StreamEvent` channel
- [x] Implement streaming output plumbing:
      - token stream from provider to TUI via channel
      - reliable cancel (user interrupt always wins via `CancelToken`)
- [x] Core agent loop:
      - build context → model → tool calls → check approvals → execute tools
        → append results → repeat
      - integration with streaming and cancellation
      - wire approval protocol into loop (pause on risky operations)
- [x] Basic responsive layout with width-aware rendering[^6][^15]:
      - Use conditional constraints based on `area.width` checks
      - Implement breakpoints (e.g., >= 100 cols for sidebar, < 100 for full-width)
      - Header: cwd, profile, provider/model, approval mode (always visible)
      - Main panel: transcript (messages + tool/action cards + inline tool output)
      - Left sidebar (collapsible on narrow terminals, >= 100 cols):
        * Token usage counter
        * Approval gates triggered count
      - Footer: single-line input composer with hints
      - No separate output pane: all tool output appears inline in transcript
- [ ] Simple transcript rendering:
      - Display user messages and model responses
      - Show tool call cards with: name, risk level, description
      - Show tool result cards inline in transcript flow
      - Basic streaming text display (append tokens as they arrive)
- [ ] Interactive approval UI:
      - Display approval prompts inline in transcript
      - Show: action type, description, affected paths, risk classification
      - Accept keyboard input: `y` (approve), `n` (reject), `c` (cancel)
      - Visual feedback on approval decision
- [ ] Basic input handling:
      - Single-line text input for user messages
      - `Enter` to submit, `Esc` to cancel generation
- [ ] Essential keybinds only:
      - `Ctrl+C` / `Esc`: cancel current generation or tool execution
      - `y` / `n` / `c`: approve/reject/cancel when approval prompt shown
      - `Ctrl+S`: toggle left sidebar (hide/show)
      - `Enter`: submit message from composer

DoD:
- A working agent loop in a basic TUI: user sends message, model responds with
  streaming text, tool calls show approval prompts, user approves/rejects,
  execution completes, and result displays inline in transcript. Layout adapts to
  terminal width gracefully (wide terminals >= 100 cols show sidebar, narrow
  terminals hide it). All tool output appears inline in the transcript flow.

--------------------------------------------------------------------------------
III. TUI HARNESS                                                     *agent-III*
--------------------------------------------------------------------------------
Polish the basic TUI into a Codex/Claude-class interactive experience with
advanced composer features, multi-panel layout, and power-user productivity.

**Enhanced Layout:**
- [ ] Expand left sidebar with additional sections (responsive to width):
      - Session Events (chronological list with filtering)
      - Modified files list (scope awareness)
      - Git diff queue preview
      - LSPs & MCPs status (placeholders)
- [ ] Enhanced header:
      - Add git branch indicator
      - Add sandbox mode status
      - Add verbosity level indicator
- [ ] Transcript enhancements:
      - Syntax highlighting for code blocks in tool output
      - Horizontal scrolling for wide output (e.g., test results, build logs)
      - Smart wrapping for long file paths and URLs

**Advanced Composer (Codex CLI parity):**
- [ ] `!cmd` shell command execution:
      - runs local command and inserts output as user-provided context
      - subject to approval/sandbox rules[^3]
- [ ] `Ctrl+G` external editor:
      - opens $VISUAL/$EDITOR for long/complex prompts[^3]
      - loads result back into composer on save
- [ ] Message history navigation:
      - up/down arrows to browse previous messages
      - edit and resubmit past messages
- [ ] `@` file search:
      - fuzzy file finder to attach context
      - shows file preview before insertion

**Slash Commands:**
- [ ] Base command set[^3]:
      - `/model` - switch provider/model
      - `/approvals` - change approval mode
      - `/status` - show session stats
- [ ] Session commands:
      - `/plan` - display PLAN.md content in transcript
      - `/review` - trigger review pass
      - `/memory` - display MEMORY.md content in transcript
      - `/clear` - clear transcript (keep session history)
- [ ] Add shell completions generation (bash/zsh/fish) for CLI and slash
      commands (Codex CLI baseline feature)[^3]

**Progressive Disclosure for Action Cards:**
- [ ] Multi-level detail expansion:
      - Level 1 (default): intent + outcome (brief, scannable)
      - Level 2 (expand): detailed context, scope, execution metadata
      - Level 3 (verbose): full logs, reasoning chain, trace
- [ ] Keybinds for card interaction:
      - `Space` / `Enter`: expand/collapse focused card
      - `v`: toggle verbose mode for focused card
      - `j` / `k`: navigate between cards

**Verbosity & Display Controls:**
- [ ] Global verbosity modes:
      - default (balanced), verbose (detailed), quiet (minimal)
      - toggle with keybind, persist per session
      - indicator in header
- [ ] Sidebar management:
      - toggle sidebar visibility (maximize transcript width)
      - sidebar sections collapsible individually
      - auto-hide sidebar on narrow terminals

**Enhanced Keybind Pack:**
- [ ] Navigation:
      - `j` / `k`: scroll transcript or navigate between action cards
      - `Ctrl+U` / `Ctrl+D`: page up/down in transcript
      - `g` / `G`: jump to top/bottom of transcript
- [ ] Sidebar controls:
      - `Ctrl+S`: toggle sidebar visibility
      - `[` / `]`: collapse/expand sidebar sections
- [ ] Action shortcuts:
      - `Ctrl+R`: retry last failed action
      - `/`: focus slash command input
      - `Ctrl+L`: clear transcript view (keep history)

DoD:
- A polished, production-ready TUI with all power-user features: responsive layout
  that adapts to terminal width, advanced composer with `!cmd` and external editor
  support, slash commands, progressive disclosure for action cards with three
  detail levels, and comprehensive keybinds for keyboard-driven workflow. All tool
  output appears inline in transcript with syntax highlighting and smart formatting.

--------------------------------------------------------------------------------
IV. APPROVALS + SANDBOXING (SHELL-FIRST, STILL SAFE)                   *agent-D*
--------------------------------------------------------------------------------
Make "anything in the shell" possible without turning the agent into malware.
Build on the basic approval system from Milestone II with policy enforcement
and pedagogical features.

Design target:
Codex's model: approval policies + sandbox modes + profiles[^2]

- [ ] Approval mode enforcement:
      - wire `read-only`, `auto`, `full-access` modes into agent loop
      - `read-only`: consultative; no edits, no commands
      - `auto`: workspace edits + safe commands; gates risky ops (default)
      - `full-access`: still logged; explicit opt-in only[^3]
- [ ] Sandbox policy enforcement:
      - define "workspace roots" in config
      - enforce tool access by path (block outside workspace)
      - default: no network commands unless approved[^2]
      - integration with tool dispatcher
- [ ] Enhance action cards with teaching context (builds on Milestone II cards):
      - "What": operation in plain language
      - "Why": context for this action in task flow
      - "Scope": files/paths affected, blast radius
      - "Risk": classification with reasoning (why safe/risky)
      - "Result": exit code, key output, next step
- [ ] First-time contextual hints:
      - track taught concepts per session (e.g., "risky_command_explained")
      - show brief explainer on first encounter
        (e.g., "network commands need approval")
      - never nag - one-time hints only

DoD:
- The agent can run `cargo test`, but will stop and ask before doing anything
  risky.

--------------------------------------------------------------------------------
V. DIFF-FIRST EDITING + GIT INTEGRATION                                *agent-E*
--------------------------------------------------------------------------------
Edits are *reviewable*, *reversible*, and *conflict-aware*.

Codex explicitly treats diffs and `git apply` failure modes as first-class
(e.g., `codex apply` exits non-zero if `git apply` fails). Mirror that rigor[^7]

- [ ] Patch queue:
      - states: `PROPOSED → APPROVED → APPLIED` or `REJECTED`
      - patch objects store base snapshot id + target files + hunks
- [ ] Unified diff generation contract for models:
      - patch-first is default; raw write is an escape hatch (heavily gated)
- [ ] Apply engine:
      - try `git apply` (or equivalent) and detect conflicts
      - on failure: enter conflict UI instead of "forcing it"
- [ ] Rollback/undo:
      - revert last applied patch (one keybind)
      - show `git diff` before/after
- [ ] Git metadata linkage:
      - attach session pointers via git notes
      - show "this commit came from session X" in TUI
- [ ] TUI enhancements (moved from Section III):
      - Diff Queue pane with hunk navigation
      - next/prev hunk keybinds
      - approve/reject individual hunks
- [ ] Hunk labeling with intent:
      - attach semantic labels to hunks
        (e.g., "Add error handling", "Remove deprecated fn")
      - display intent above each hunk in diff view
      - teach version control discipline through consistent labeling
- [ ] Pedagogical conflict messages:
      - on `git apply` failure, explain *why* conflict occurred
        (not just "conflict detected")
      - show conflicting regions with context
      - suggest resolution strategies (rebase, manual merge, discard)
      - first conflict triggers brief explainer on 3-way merge

DoD:
- "PR-stack feel" inside a TUI: accept hunks, undo safely, never lose work.

--------------------------------------------------------------------------------
VI. MARKDOWN + JSONL HYBRID VCS                                       *agent-VI*
--------------------------------------------------------------------------------
Your hybrid system is the canonical record of agent work, and it improves
collaboration and debugging.

- [ ] JSONL event model (append-only) in `events.jsonl`:
      - user msgs, model msgs, tool calls/results, approvals, patches,
      - shell outputs (by reference), git snapshots
- [ ] Materialized Markdown views:
      - `MEMORY.md` (always-loaded "project memory", Claude-style)
      - `PLAN.md` (current plan + checkpoints)
      - `DECISIONS.md` (ADR-lite)[^1]
- [ ] "CLAUDE.md compatibility":
      - if repo has `CLAUDE.md`, import it into context automatically because
        Claude Code uses it as auto-context[^1]
- [ ] View materializer:
      - deterministic regeneration from JSONL + explicit user edits logged as
        events
- [ ] Fast search:
      - ripgrep recipes surfaced in-app for events + views
- [ ] TUI enhancements (moved from Section III):
      - Context pane with view content
      - Files pane for file system browsing
      - `/plan`, `/review`, `/memory` slash commands
      - `@` file search in composer

DoD:
- You can reconstruct *exactly* what happened in a session and why.

--------------------------------------------------------------------------------
VII. MIXED-INITIATIVE COLLABORATION                                  *agent-VII*
--------------------------------------------------------------------------------
When you work alongside the agent, it pauses, notices drift, and reconciles.

- [ ] Drift detection (mandatory gate at every step boundary):
      - compare repo snapshot IDs; if changed → stop and require reconcile
- [ ] "User right-of-way" state machine:
      - any keystroke/edit cancels generation or tool execution immediately
- [ ] Reconcile ritual (single predictable flow):
      1. summarize changed files/diffstat
      2. choose: update plan & continue / rebase pending patches / discard
      3. refresh context and revalidate plan before acting again
      - enhance with choice implications (teach trade-offs of each option)
      - first drift triggers brief explainer:
        "Agent paused - you edited files. Let's reconcile"
- [ ] File ownership rule:
      - files you touched become "user-owned"; agent needs explicit approval to
        modify them until reconcile completes
- [ ] Advisor mode toggle:
      - consultative suggestions only (maps to read-only/approval modes)[^3]
- [ ] TUI enhancements (moved from Section III):
      - History editing: "edit previous message / fork from point"
      - Esc-based rewind behavior

DoD:
- The agent never proceeds on stale assumptions after you fix something manually

--------------------------------------------------------------------------------
VIII. EXTENSIBILITY + HARDENING                                     *agent-VIII*
--------------------------------------------------------------------------------
Match the "pro tool" feel: pluggable integrations, automation entrypoints,
and regression tests for harness behaviors.

- [ ] MCP client:
      - load MCP servers from config, import tool schemas, route calls
      - respect approval/sandbox across MCP tools[^8]
- [ ] Web search tool:
      - either provider-native (Gemini tools) or shell-gated `web_search`
        equivalent
            - Mojeek API
            - Brave API
            - Tavily API
      - treat results as tool outputs and log them[^9]
- [ ] Non-interactive mode (`thunderus exec "…"`) like Codex's `exec`:
      - emits JSON (machine output) + writes JSONL session log[^3]
- [ ] "review agent" (second pass) like Codex `/review` flow[^3]
- [ ] Harness regression tests (golden scenarios):
      - interrupt mid-tool, drift+reconcile, patch conflict UI, approval gating
- [ ] TUI enhancements (moved from Section III):
      - Permissions pane in sidebar
      - toggle verbose action trace keybind
- [ ] Session-based teaching state:
      - persist "taught concepts" in session metadata
      - track which pedagogical hints have been shown
        (e.g., `taught: [patch_conflict, risky_command]`)
      - prevent repetitive hints across session lifecycle
      - expose teaching history in session events for debugging

DoD:
- A daily-driver harness: interactive + scriptable + extensible.

--------------------------------------------------------------------------------
IX. NOTES                                                        *roadmap-notes*
--------------------------------------------------------------------------------

- Codex CLI: approval modes, sandbox/approvals posture, composer affordances
  (`@` file search, `!` local commands), slash commands, prompt editor[^3]
- Claude Code: repo-local memory file (`CLAUDE.md`) auto-loaded as context[^1]
- MCP: standardized tool/plugin surface to avoid hardcoding integrations[^10]
- Progressive Disclosure: UX pattern for teaching through staged information
  reveal, reducing cognitive load while supporting power users[^11][^12].
  Research shows 90% of organizations consider AI transparency essential, and
  explainability is key to building trust in agentic systems[^13][^14]

[^1]: https://www.anthropic.com/engineering/claude-code-best-practices
[^2]: https://developers.openai.com/codex/security/
[^3]: https://developers.openai.com/codex/cli/features/
[^4]: https://ai.google.dev/gemini-api/docs/function-calling
[^5]: https://docs.z.ai/guides/llm/glm-4.7
[^6]: https://ratatui.rs/
[^7]: https://developers.openai.com/codex/cli/reference/
[^8]: https://modelcontextprotocol.io/
[^9]: https://ai.google.dev/gemini-api/docs/tools
[^10]: https://modelcontextprotocol.io/specification/2025-11-25
[^11]: https://www.nngroup.com/articles/progressive-disclosure/
[^12]: https://blog.logrocket.com/ux-design/progressive-disclosure-ux-types-use-cases/
[^13]: https://arxiv.org/html/2502.13767v3
       (Agentic AI Software Engineers: Programming with Trust)
[^14]: https://witness.ai/blog/ai-transparency/
[^15]: https://ratatui.rs/concepts/layout/
       https://kdheepak.com/blog/the-basic-building-blocks-of-ratatui-part-2/
       Ratatui responsive layouts - conditional constraints (area.width checks)
